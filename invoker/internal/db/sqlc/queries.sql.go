// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredOAuthLogins = `-- name: CleanupExpiredOAuthLogins :exec
DELETE FROM pending_oauth_logins
WHERE expires_at <= EXTRACT(EPOCH FROM NOW()) * 1000
`

func (q *Queries) CleanupExpiredOAuthLogins(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredOAuthLogins)
	return err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_log (id, profile_id, action, resource_type, resource_id, ip_address, user_agent, metadata, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, profile_id, action, resource_type, resource_id, ip_address, user_agent, metadata, created_at
`

type CreateAuditLogParams struct {
	ID           string      `json:"id"`
	ProfileID    pgtype.Text `json:"profile_id"`
	Action       string      `json:"action"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
	IpAddress    pgtype.Text `json:"ip_address"`
	UserAgent    pgtype.Text `json:"user_agent"`
	Metadata     []byte      `json:"metadata"`
	CreatedAt    int64       `json:"created_at"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.ID,
		arg.ProfileID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.IpAddress,
		&i.UserAgent,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createMachineAuth = `-- name: CreateMachineAuth :one
INSERT INTO machine_auth (id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active
`

type CreateMachineAuthParams struct {
	ID             string      `json:"id"`
	MachineID      string      `json:"machine_id"`
	ProfileID      string      `json:"profile_id"`
	Subdomain      string      `json:"subdomain"`
	TunnelProvider string      `json:"tunnel_provider"`
	TunnelToken    string      `json:"tunnel_token"`
	CreatedAt      int64       `json:"created_at"`
	LastSeenAt     pgtype.Int8 `json:"last_seen_at"`
	IsActive       bool        `json:"is_active"`
}

// Machine auth queries
func (q *Queries) CreateMachineAuth(ctx context.Context, arg CreateMachineAuthParams) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, createMachineAuth,
		arg.ID,
		arg.MachineID,
		arg.ProfileID,
		arg.Subdomain,
		arg.TunnelProvider,
		arg.TunnelToken,
		arg.CreatedAt,
		arg.LastSeenAt,
		arg.IsActive,
	)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const createMachineRegistry = `-- name: CreateMachineRegistry :one
INSERT INTO machine_registry (id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message
`

type CreateMachineRegistryParams struct {
	ID              string      `json:"id"`
	ProfileID       string      `json:"profile_id"`
	FlyMachineID    string      `json:"fly_machine_id"`
	FlyAppName      string      `json:"fly_app_name"`
	Status          string      `json:"status"`
	Subdomain       string      `json:"subdomain"`
	PublicUrl       string      `json:"public_url"`
	Region          string      `json:"region"`
	VmSize          string      `json:"vm_size"`
	VolumeID        pgtype.Text `json:"volume_id"`
	CreatedAt       int64       `json:"created_at"`
	LastSeenAt      int64       `json:"last_seen_at"`
	LastHeartbeatAt pgtype.Int8 `json:"last_heartbeat_at"`
	ErrorMessage    pgtype.Text `json:"error_message"`
}

func (q *Queries) CreateMachineRegistry(ctx context.Context, arg CreateMachineRegistryParams) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, createMachineRegistry,
		arg.ID,
		arg.ProfileID,
		arg.FlyMachineID,
		arg.FlyAppName,
		arg.Status,
		arg.Subdomain,
		arg.PublicUrl,
		arg.Region,
		arg.VmSize,
		arg.VolumeID,
		arg.CreatedAt,
		arg.LastSeenAt,
		arg.LastHeartbeatAt,
		arg.ErrorMessage,
	)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const createPendingOAuthLogin = `-- name: CreatePendingOAuthLogin :one
INSERT INTO pending_oauth_logins (id, state, code_challenge, redirect_uri, created_at, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, state, code_challenge, redirect_uri, auth_code, created_at, expires_at
`

type CreatePendingOAuthLoginParams struct {
	ID            string `json:"id"`
	State         string `json:"state"`
	CodeChallenge string `json:"code_challenge"`
	RedirectUri   string `json:"redirect_uri"`
	CreatedAt     int64  `json:"created_at"`
	ExpiresAt     int64  `json:"expires_at"`
}

// OAuth pending logins queries
func (q *Queries) CreatePendingOAuthLogin(ctx context.Context, arg CreatePendingOAuthLoginParams) (PendingOauthLogin, error) {
	row := q.db.QueryRow(ctx, createPendingOAuthLogin,
		arg.ID,
		arg.State,
		arg.CodeChallenge,
		arg.RedirectUri,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	var i PendingOauthLogin
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CodeChallenge,
		&i.RedirectUri,
		&i.AuthCode,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createRoutingTable = `-- name: CreateRoutingTable :one
INSERT INTO routing_table (subdomain, fly_machine_id, fly_url, is_active, updated_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING subdomain, fly_machine_id, fly_url, is_active, updated_at
`

type CreateRoutingTableParams struct {
	Subdomain    string `json:"subdomain"`
	FlyMachineID string `json:"fly_machine_id"`
	FlyUrl       string `json:"fly_url"`
	IsActive     bool   `json:"is_active"`
	UpdatedAt    int64  `json:"updated_at"`
}

func (q *Queries) CreateRoutingTable(ctx context.Context, arg CreateRoutingTableParams) (RoutingTable, error) {
	row := q.db.QueryRow(ctx, createRoutingTable,
		arg.Subdomain,
		arg.FlyMachineID,
		arg.FlyUrl,
		arg.IsActive,
		arg.UpdatedAt,
	)
	var i RoutingTable
	err := row.Scan(
		&i.Subdomain,
		&i.FlyMachineID,
		&i.FlyUrl,
		&i.IsActive,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at
`

type CreateSubscriptionParams struct {
	ID                 string      `json:"id"`
	ProfileID          string      `json:"profile_id"`
	StripeSubID        pgtype.Text `json:"stripe_sub_id"`
	Tier               string      `json:"tier"`
	Status             string      `json:"status"`
	CurrentPeriodStart int64       `json:"current_period_start"`
	CurrentPeriodEnd   int64       `json:"current_period_end"`
	CancelAtPeriodEnd  bool        `json:"cancel_at_period_end"`
	CreatedAt          int64       `json:"created_at"`
	UpdatedAt          int64       `json:"updated_at"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.ID,
		arg.ProfileID,
		arg.StripeSubID,
		arg.Tier,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAtPeriodEnd,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.StripeSubID,
		&i.Tier,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUsageTracking = `-- name: CreateUsageTracking :one
INSERT INTO usage_tracking (id, profile_id, machine_id, metric_type, quantity, recorded_at, period_start, period_end)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, profile_id, machine_id, metric_type, quantity, recorded_at, period_start, period_end
`

type CreateUsageTrackingParams struct {
	ID          string `json:"id"`
	ProfileID   string `json:"profile_id"`
	MachineID   string `json:"machine_id"`
	MetricType  string `json:"metric_type"`
	Quantity    int32  `json:"quantity"`
	RecordedAt  int64  `json:"recorded_at"`
	PeriodStart int64  `json:"period_start"`
	PeriodEnd   int64  `json:"period_end"`
}

func (q *Queries) CreateUsageTracking(ctx context.Context, arg CreateUsageTrackingParams) (UsageTracking, error) {
	row := q.db.QueryRow(ctx, createUsageTracking,
		arg.ID,
		arg.ProfileID,
		arg.MachineID,
		arg.MetricType,
		arg.Quantity,
		arg.RecordedAt,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	var i UsageTracking
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.MachineID,
		&i.MetricType,
		&i.Quantity,
		&i.RecordedAt,
		&i.PeriodStart,
		&i.PeriodEnd,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO profiles (id, email, first_name, last_name, username, tier, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, email, first_name, last_name, username, tier, created_at, updated_at
`

type CreateUserParams struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Username  string `json:"username"`
	Tier      string `json:"tier"`
	CreatedAt int64  `json:"created_at"`
	UpdatedAt int64  `json:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Profile, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Tier,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Tier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMachineRegistry = `-- name: DeleteMachineRegistry :exec
DELETE FROM machine_registry
WHERE id = $1
`

func (q *Queries) DeleteMachineRegistry(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteMachineRegistry, id)
	return err
}

const deletePendingOAuthLogin = `-- name: DeletePendingOAuthLogin :exec
DELETE FROM pending_oauth_logins
WHERE state = $1
`

func (q *Queries) DeletePendingOAuthLogin(ctx context.Context, state string) error {
	_, err := q.db.Exec(ctx, deletePendingOAuthLogin, state)
	return err
}

const deleteRoutingTable = `-- name: DeleteRoutingTable :exec
DELETE FROM routing_table
WHERE subdomain = $1
`

func (q *Queries) DeleteRoutingTable(ctx context.Context, subdomain string) error {
	_, err := q.db.Exec(ctx, deleteRoutingTable, subdomain)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM profiles
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const emailExists = `-- name: EmailExists :one
SELECT EXISTS(SELECT 1 FROM profiles WHERE email = $1)
`

func (q *Queries) EmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getMachineAuthByMachineID = `-- name: GetMachineAuthByMachineID :one
SELECT id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active FROM machine_auth
WHERE machine_id = $1 AND is_active = TRUE
`

func (q *Queries) GetMachineAuthByMachineID(ctx context.Context, machineID string) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, getMachineAuthByMachineID, machineID)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const getMachineAuthBySubdomain = `-- name: GetMachineAuthBySubdomain :one
SELECT id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active FROM machine_auth
WHERE subdomain = $1 AND is_active = TRUE
`

func (q *Queries) GetMachineAuthBySubdomain(ctx context.Context, subdomain string) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, getMachineAuthBySubdomain, subdomain)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const getMachineAuthByUserID = `-- name: GetMachineAuthByUserID :many
SELECT id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active FROM machine_auth
WHERE profile_id = $1 AND is_active = TRUE
ORDER BY created_at DESC
`

func (q *Queries) GetMachineAuthByUserID(ctx context.Context, profileID string) ([]MachineAuth, error) {
	rows, err := q.db.Query(ctx, getMachineAuthByUserID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MachineAuth{}
	for rows.Next() {
		var i MachineAuth
		if err := rows.Scan(
			&i.ID,
			&i.MachineID,
			&i.ProfileID,
			&i.Subdomain,
			&i.TunnelProvider,
			&i.TunnelToken,
			&i.CreatedAt,
			&i.LastSeenAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMachineRegistryByFlyMachineID = `-- name: GetMachineRegistryByFlyMachineID :one
SELECT id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message FROM machine_registry
WHERE fly_machine_id = $1
`

func (q *Queries) GetMachineRegistryByFlyMachineID(ctx context.Context, flyMachineID string) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, getMachineRegistryByFlyMachineID, flyMachineID)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getMachineRegistryByID = `-- name: GetMachineRegistryByID :one
SELECT id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message FROM machine_registry
WHERE id = $1
`

func (q *Queries) GetMachineRegistryByID(ctx context.Context, id string) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, getMachineRegistryByID, id)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getMachineRegistryBySubdomain = `-- name: GetMachineRegistryBySubdomain :one
SELECT id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message FROM machine_registry
WHERE subdomain = $1
`

func (q *Queries) GetMachineRegistryBySubdomain(ctx context.Context, subdomain string) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, getMachineRegistryBySubdomain, subdomain)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getMachineRegistryByUserID = `-- name: GetMachineRegistryByUserID :many
SELECT id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message FROM machine_registry
WHERE profile_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetMachineRegistryByUserID(ctx context.Context, profileID string) ([]MachineRegistry, error) {
	rows, err := q.db.Query(ctx, getMachineRegistryByUserID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MachineRegistry{}
	for rows.Next() {
		var i MachineRegistry
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.FlyMachineID,
			&i.FlyAppName,
			&i.Status,
			&i.Subdomain,
			&i.PublicUrl,
			&i.Region,
			&i.VmSize,
			&i.VolumeID,
			&i.CreatedAt,
			&i.LastSeenAt,
			&i.LastHeartbeatAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingOAuthLoginByState = `-- name: GetPendingOAuthLoginByState :one
SELECT id, state, code_challenge, redirect_uri, auth_code, created_at, expires_at FROM pending_oauth_logins
WHERE state = $1 AND expires_at > EXTRACT(EPOCH FROM NOW()) * 1000
`

func (q *Queries) GetPendingOAuthLoginByState(ctx context.Context, state string) (PendingOauthLogin, error) {
	row := q.db.QueryRow(ctx, getPendingOAuthLoginByState, state)
	var i PendingOauthLogin
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CodeChallenge,
		&i.RedirectUri,
		&i.AuthCode,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getQuotaLimitByTier = `-- name: GetQuotaLimitByTier :one
SELECT tier, max_vm_count, max_vm_hours_per_month, max_tasks_per_month, max_api_requests_per_month, created_at, updated_at FROM quota_limits
WHERE tier = $1
`

func (q *Queries) GetQuotaLimitByTier(ctx context.Context, tier string) (QuotaLimit, error) {
	row := q.db.QueryRow(ctx, getQuotaLimitByTier, tier)
	var i QuotaLimit
	err := row.Scan(
		&i.Tier,
		&i.MaxVmCount,
		&i.MaxVmHoursPerMonth,
		&i.MaxTasksPerMonth,
		&i.MaxApiRequestsPerMonth,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoutingTableBySubdomain = `-- name: GetRoutingTableBySubdomain :one
SELECT subdomain, fly_machine_id, fly_url, is_active, updated_at FROM routing_table
WHERE subdomain = $1
`

func (q *Queries) GetRoutingTableBySubdomain(ctx context.Context, subdomain string) (RoutingTable, error) {
	row := q.db.QueryRow(ctx, getRoutingTableBySubdomain, subdomain)
	var i RoutingTable
	err := row.Scan(
		&i.Subdomain,
		&i.FlyMachineID,
		&i.FlyUrl,
		&i.IsActive,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id string) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.StripeSubID,
		&i.Tier,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByUserID = `-- name: GetSubscriptionByUserID :one
SELECT id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at FROM subscriptions
WHERE profile_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetSubscriptionByUserID(ctx context.Context, profileID string) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByUserID, profileID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.StripeSubID,
		&i.Tier,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsageTrackingByUserIDAndPeriod = `-- name: GetUsageTrackingByUserIDAndPeriod :many
SELECT id, profile_id, machine_id, metric_type, quantity, recorded_at, period_start, period_end FROM usage_tracking
WHERE profile_id = $1 AND period_start >= $2 AND period_end <= $3
ORDER BY recorded_at DESC
`

type GetUsageTrackingByUserIDAndPeriodParams struct {
	ProfileID   string `json:"profile_id"`
	PeriodStart int64  `json:"period_start"`
	PeriodEnd   int64  `json:"period_end"`
}

func (q *Queries) GetUsageTrackingByUserIDAndPeriod(ctx context.Context, arg GetUsageTrackingByUserIDAndPeriodParams) ([]UsageTracking, error) {
	rows, err := q.db.Query(ctx, getUsageTrackingByUserIDAndPeriod, arg.ProfileID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageTracking{}
	for rows.Next() {
		var i UsageTracking
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.MachineID,
			&i.MetricType,
			&i.Quantity,
			&i.RecordedAt,
			&i.PeriodStart,
			&i.PeriodEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, first_name, last_name, username, tier, created_at, updated_at FROM profiles
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Profile, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Tier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, first_name, last_name, username, tier, created_at, updated_at FROM profiles
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (Profile, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Tier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, first_name, last_name, username, tier, created_at, updated_at FROM profiles
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (Profile, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Tier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, profile_id, action, resource_type, resource_id, ip_address, user_agent, metadata, created_at FROM audit_log
WHERE profile_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListAuditLogsParams struct {
	ProfileID pgtype.Text `json:"profile_id"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs, arg.ProfileID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachineRegistry = `-- name: ListMachineRegistry :many
SELECT id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message FROM machine_registry
ORDER BY created_at DESC
`

func (q *Queries) ListMachineRegistry(ctx context.Context) ([]MachineRegistry, error) {
	rows, err := q.db.Query(ctx, listMachineRegistry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MachineRegistry{}
	for rows.Next() {
		var i MachineRegistry
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.FlyMachineID,
			&i.FlyAppName,
			&i.Status,
			&i.Subdomain,
			&i.PublicUrl,
			&i.Region,
			&i.VmSize,
			&i.VolumeID,
			&i.CreatedAt,
			&i.LastSeenAt,
			&i.LastHeartbeatAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotaLimits = `-- name: ListQuotaLimits :many
SELECT tier, max_vm_count, max_vm_hours_per_month, max_tasks_per_month, max_api_requests_per_month, created_at, updated_at FROM quota_limits
ORDER BY tier
`

func (q *Queries) ListQuotaLimits(ctx context.Context) ([]QuotaLimit, error) {
	rows, err := q.db.Query(ctx, listQuotaLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuotaLimit{}
	for rows.Next() {
		var i QuotaLimit
		if err := rows.Scan(
			&i.Tier,
			&i.MaxVmCount,
			&i.MaxVmHoursPerMonth,
			&i.MaxTasksPerMonth,
			&i.MaxApiRequestsPerMonth,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutingTable = `-- name: ListRoutingTable :many
SELECT subdomain, fly_machine_id, fly_url, is_active, updated_at FROM routing_table
ORDER BY updated_at DESC
`

func (q *Queries) ListRoutingTable(ctx context.Context) ([]RoutingTable, error) {
	rows, err := q.db.Query(ctx, listRoutingTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RoutingTable{}
	for rows.Next() {
		var i RoutingTable
		if err := rows.Scan(
			&i.Subdomain,
			&i.FlyMachineID,
			&i.FlyUrl,
			&i.IsActive,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByUser = `-- name: ListSubscriptionsByUser :many
SELECT id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at FROM subscriptions
WHERE profile_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByUser(ctx context.Context, profileID string) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByUser, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.StripeSubID,
			&i.Tier,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsageTracking = `-- name: ListUsageTracking :many
SELECT id, profile_id, machine_id, metric_type, quantity, recorded_at, period_start, period_end FROM usage_tracking
ORDER BY recorded_at DESC
`

func (q *Queries) ListUsageTracking(ctx context.Context) ([]UsageTracking, error) {
	rows, err := q.db.Query(ctx, listUsageTracking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageTracking{}
	for rows.Next() {
		var i UsageTracking
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.MachineID,
			&i.MetricType,
			&i.Quantity,
			&i.RecordedAt,
			&i.PeriodStart,
			&i.PeriodEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listprofiles = `-- name: Listprofiles :many
SELECT id, email, first_name, last_name, username, tier, created_at, updated_at FROM profiles
ORDER BY created_at DESC
`

func (q *Queries) Listprofiles(ctx context.Context) ([]Profile, error) {
	rows, err := q.db.Query(ctx, listprofiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Profile{}
	for rows.Next() {
		var i Profile
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Tier,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeMachineAuth = `-- name: RevokeMachineAuth :one
UPDATE machine_auth
SET is_active = FALSE
WHERE machine_id = $1
RETURNING id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active
`

func (q *Queries) RevokeMachineAuth(ctx context.Context, machineID string) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, revokeMachineAuth, machineID)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const updateMachineAuthLastSeen = `-- name: UpdateMachineAuthLastSeen :one
UPDATE machine_auth
SET last_seen_at = $2
WHERE machine_id = $1
RETURNING id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active
`

type UpdateMachineAuthLastSeenParams struct {
	MachineID  string      `json:"machine_id"`
	LastSeenAt pgtype.Int8 `json:"last_seen_at"`
}

func (q *Queries) UpdateMachineAuthLastSeen(ctx context.Context, arg UpdateMachineAuthLastSeenParams) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, updateMachineAuthLastSeen, arg.MachineID, arg.LastSeenAt)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const updateMachineAuthTunnel = `-- name: UpdateMachineAuthTunnel :one
UPDATE machine_auth
SET tunnel_provider = $2, tunnel_token = $3, subdomain = $4
WHERE machine_id = $1 AND is_active = TRUE
RETURNING id, machine_id, profile_id, subdomain, tunnel_provider, tunnel_token, created_at, last_seen_at, is_active
`

type UpdateMachineAuthTunnelParams struct {
	MachineID      string `json:"machine_id"`
	TunnelProvider string `json:"tunnel_provider"`
	TunnelToken    string `json:"tunnel_token"`
	Subdomain      string `json:"subdomain"`
}

func (q *Queries) UpdateMachineAuthTunnel(ctx context.Context, arg UpdateMachineAuthTunnelParams) (MachineAuth, error) {
	row := q.db.QueryRow(ctx, updateMachineAuthTunnel,
		arg.MachineID,
		arg.TunnelProvider,
		arg.TunnelToken,
		arg.Subdomain,
	)
	var i MachineAuth
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.ProfileID,
		&i.Subdomain,
		&i.TunnelProvider,
		&i.TunnelToken,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.IsActive,
	)
	return i, err
}

const updateMachineRegistry = `-- name: UpdateMachineRegistry :one
UPDATE machine_registry
SET status = $2, last_seen_at = $3, last_heartbeat_at = $4, error_message = $5
WHERE id = $1
RETURNING id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message
`

type UpdateMachineRegistryParams struct {
	ID              string      `json:"id"`
	Status          string      `json:"status"`
	LastSeenAt      int64       `json:"last_seen_at"`
	LastHeartbeatAt pgtype.Int8 `json:"last_heartbeat_at"`
	ErrorMessage    pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateMachineRegistry(ctx context.Context, arg UpdateMachineRegistryParams) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, updateMachineRegistry,
		arg.ID,
		arg.Status,
		arg.LastSeenAt,
		arg.LastHeartbeatAt,
		arg.ErrorMessage,
	)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const updateMachineRegistryStatus = `-- name: UpdateMachineRegistryStatus :one
UPDATE machine_registry
SET status = $2, last_seen_at = $3, error_message = $4
WHERE id = $1
RETURNING id, profile_id, fly_machine_id, fly_app_name, status, subdomain, public_url, region, vm_size, volume_id, created_at, last_seen_at, last_heartbeat_at, error_message
`

type UpdateMachineRegistryStatusParams struct {
	ID           string      `json:"id"`
	Status       string      `json:"status"`
	LastSeenAt   int64       `json:"last_seen_at"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateMachineRegistryStatus(ctx context.Context, arg UpdateMachineRegistryStatusParams) (MachineRegistry, error) {
	row := q.db.QueryRow(ctx, updateMachineRegistryStatus,
		arg.ID,
		arg.Status,
		arg.LastSeenAt,
		arg.ErrorMessage,
	)
	var i MachineRegistry
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.FlyMachineID,
		&i.FlyAppName,
		&i.Status,
		&i.Subdomain,
		&i.PublicUrl,
		&i.Region,
		&i.VmSize,
		&i.VolumeID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastHeartbeatAt,
		&i.ErrorMessage,
	)
	return i, err
}

const updatePendingOAuthLoginAuthCode = `-- name: UpdatePendingOAuthLoginAuthCode :one
UPDATE pending_oauth_logins
SET auth_code = $2
WHERE state = $1 AND expires_at > EXTRACT(EPOCH FROM NOW()) * 1000
RETURNING id, state, code_challenge, redirect_uri, auth_code, created_at, expires_at
`

type UpdatePendingOAuthLoginAuthCodeParams struct {
	State    string `json:"state"`
	AuthCode string `json:"auth_code"`
}

func (q *Queries) UpdatePendingOAuthLoginAuthCode(ctx context.Context, arg UpdatePendingOAuthLoginAuthCodeParams) (PendingOauthLogin, error) {
	row := q.db.QueryRow(ctx, updatePendingOAuthLoginAuthCode, arg.State, arg.AuthCode)
	var i PendingOauthLogin
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CodeChallenge,
		&i.RedirectUri,
		&i.AuthCode,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateRoutingTable = `-- name: UpdateRoutingTable :one
UPDATE routing_table
SET fly_machine_id = $2, fly_url = $3, is_active = $4, updated_at = $5
WHERE subdomain = $1
RETURNING subdomain, fly_machine_id, fly_url, is_active, updated_at
`

type UpdateRoutingTableParams struct {
	Subdomain    string `json:"subdomain"`
	FlyMachineID string `json:"fly_machine_id"`
	FlyUrl       string `json:"fly_url"`
	IsActive     bool   `json:"is_active"`
	UpdatedAt    int64  `json:"updated_at"`
}

func (q *Queries) UpdateRoutingTable(ctx context.Context, arg UpdateRoutingTableParams) (RoutingTable, error) {
	row := q.db.QueryRow(ctx, updateRoutingTable,
		arg.Subdomain,
		arg.FlyMachineID,
		arg.FlyUrl,
		arg.IsActive,
		arg.UpdatedAt,
	)
	var i RoutingTable
	err := row.Scan(
		&i.Subdomain,
		&i.FlyMachineID,
		&i.FlyUrl,
		&i.IsActive,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET tier = $2, status = $3, current_period_start = $4, current_period_end = $5, cancel_at_period_end = $6, updated_at = $7
WHERE id = $1
RETURNING id, profile_id, stripe_sub_id, tier, status, current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	ID                 string `json:"id"`
	Tier               string `json:"tier"`
	Status             string `json:"status"`
	CurrentPeriodStart int64  `json:"current_period_start"`
	CurrentPeriodEnd   int64  `json:"current_period_end"`
	CancelAtPeriodEnd  bool   `json:"cancel_at_period_end"`
	UpdatedAt          int64  `json:"updated_at"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.ID,
		arg.Tier,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAtPeriodEnd,
		arg.UpdatedAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.StripeSubID,
		&i.Tier,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE profiles
SET email = $2, first_name = $3, last_name = $4, username = $5, tier = $6, updated_at = $7
WHERE id = $1
RETURNING id, email, first_name, last_name, username, tier, created_at, updated_at
`

type UpdateUserParams struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Username  string `json:"username"`
	Tier      string `json:"tier"`
	UpdatedAt int64  `json:"updated_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Profile, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Tier,
		arg.UpdatedAt,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Tier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const usernameExists = `-- name: UsernameExists :one
SELECT EXISTS(SELECT 1 FROM profiles WHERE username = $1)
`

func (q *Queries) UsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, usernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
