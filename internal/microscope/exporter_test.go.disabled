package microscope

import (
	"context"
	"database/sql"
	"encoding/json"
	"testing"
	"time"

	_ "github.com/mattn/go-sqlite3"
	"github.com/your-github-username/microscope/internal/db"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/sdk/resource"
	"go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
	oteltrace "go.opentelemetry.io/otel/trace"
)

func setupTestDB(t *testing.T) *sql.DB {
	database, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open test database: %v", err)
	}

	// Create the spans table
	_, err = database.Exec(`
		CREATE TABLE spans (
			span_id TEXT PRIMARY KEY,
			trace_id TEXT NOT NULL,
			parent_span_id TEXT,
			name TEXT NOT NULL,
			start_time TEXT NOT NULL,
			end_time TEXT NOT NULL,
			duration_ns INTEGER NOT NULL,
			attributes TEXT,
			service_name TEXT NOT NULL,
			has_error BOOLEAN NOT NULL DEFAULT FALSE
		);
		CREATE INDEX idx_spans_trace_id ON spans(trace_id);
		CREATE INDEX idx_spans_start_time ON spans(start_time);
	`)
	if err != nil {
		t.Fatalf("Failed to create test table: %v", err)
	}

	return database
}

func createTestSpan(traceID, spanID, name string, hasError bool) trace.ReadOnlySpan {
	// Create a mock span for testing
	traceIDBytes, _ := oteltrace.TraceIDFromHex(traceID)
	spanIDBytes, _ := oteltrace.SpanIDFromHex(spanID)
	
	spanContext := oteltrace.NewSpanContext(oteltrace.SpanContextConfig{
		TraceID: traceIDBytes,
		SpanID:  spanIDBytes,
	})

	// Create resource
	res, _ := resource.New(context.Background(),
		resource.WithAttributes(semconv.ServiceNameKey.String("test-service")),
	)

	startTime := time.Now()
	endTime := startTime.Add(100 * time.Millisecond)

	// Create attributes
	attrs := []attribute.KeyValue{
		attribute.String("http.method", "GET"),
		attribute.String("http.url", "/test"),
	}

	status := codes.Ok
	if hasError {
		status = codes.Error
	}

	// Create a basic span data structure (simplified for testing)
	span := &testReadOnlySpan{
		spanContext: spanContext,
		name:        name,
		startTime:   startTime,
		endTime:     endTime,
		attributes:  attrs,
		status:      trace.Status{Code: status},
		resource:    res,
	}

	return span
}

// testReadOnlySpan implements trace.ReadOnlySpan for testing
type testReadOnlySpan struct {
	spanContext oteltrace.SpanContext
	name        string
	startTime   time.Time
	endTime     time.Time
	attributes  []attribute.KeyValue
	status      trace.Status
	resource    *resource.Resource
}

func (s *testReadOnlySpan) Name() string                                { return s.name }
func (s *testReadOnlySpan) SpanContext() oteltrace.SpanContext          { return s.spanContext }
func (s *testReadOnlySpan) Parent() oteltrace.SpanContext               { return oteltrace.SpanContext{} }
func (s *testReadOnlySpan) SpanKind() oteltrace.SpanKind                { return oteltrace.SpanKindServer }
func (s *testReadOnlySpan) StartTime() time.Time                        { return s.startTime }
func (s *testReadOnlySpan) EndTime() time.Time                          { return s.endTime }
func (s *testReadOnlySpan) Attributes() []attribute.KeyValue            { return s.attributes }
func (s *testReadOnlySpan) Links() []trace.Link                         { return nil }
func (s *testReadOnlySpan) Events() []trace.Event                       { return nil }
func (s *testReadOnlySpan) Status() trace.Status                        { return s.status }
func (s *testReadOnlySpan) Resource() *resource.Resource                 { return s.resource }
// func (s *testReadOnlySpan) InstrumentationLibrary() trace.InstrumentationLibrary { return trace.InstrumentationLibrary{} }
func (s *testReadOnlySpan) DroppedAttributes() int                       { return 0 }
func (s *testReadOnlySpan) DroppedLinks() int                           { return 0 }
func (s *testReadOnlySpan) DroppedEvents() int                          { return 0 }
func (s *testReadOnlySpan) ChildSpanCount() int                         { return 0 }

func TestSQLiteSpanExporter_ExportSpans(t *testing.T) {
	database := setupTestDB(t)
	defer database.Close()

	exporter := NewSQLiteSpanExporter(database)
	defer exporter.Shutdown(context.Background())

	// Create test spans
	span1 := createTestSpan("1234567890abcdef1234567890abcdef", "1234567890abcdef", "test-span-1", false)
	span2 := createTestSpan("1234567890abcdef1234567890abcdef", "abcdef1234567890", "test-span-2", true)

	spans := []trace.ReadOnlySpan{span1, span2}

	// Export spans
	err := exporter.ExportSpans(context.Background(), spans)
	if err != nil {
		t.Fatalf("Failed to export spans: %v", err)
	}

	// Give some time for async processing
	time.Sleep(100 * time.Millisecond)

	// Verify spans were written to database
	queries := db.New(database)
	dbSpans, err := queries.GetTraceDetails(context.Background(), "1234567890abcdef1234567890abcdef")
	if err != nil {
		t.Fatalf("Failed to query spans: %v", err)
	}

	if len(dbSpans) != 2 {
		t.Errorf("Expected 2 spans, got %d", len(dbSpans))
	}

	// Check first span
	if dbSpans[0].Name != "test-span-1" {
		t.Errorf("Expected span name 'test-span-1', got '%s'", dbSpans[0].Name)
	}
	if dbSpans[0].HasError {
		t.Errorf("Expected span to not have error, but it does")
	}

	// Check second span (error span)
	errorSpan := dbSpans[1]
	if !errorSpan.HasError {
		t.Errorf("Expected span to have error, but it doesn't")
	}

	// Check attributes were serialized properly
	var attrs map[string]interface{}
	if err := json.Unmarshal([]byte(errorSpan.Attributes.String), &attrs); err != nil {
		t.Errorf("Failed to parse attributes JSON: %v", err)
	}
	if attrs["http.method"] != "GET" {
		t.Errorf("Expected http.method to be 'GET', got '%v'", attrs["http.method"])
	}
}

func TestSQLiteSpanExporter_BatchProcessing(t *testing.T) {
	database := setupTestDB(t)
	defer database.Close()

	exporter := NewSQLiteSpanExporter(database)
	defer exporter.Shutdown(context.Background())

	// Create many spans to test batching
	var spans []trace.ReadOnlySpan
	for i := 0; i < 250; i++ { // More than batch size (100)
		traceID := "1234567890abcdef1234567890abcdef"
		spanID := "123456789012345" + string(rune('0'+i%10))
		span := createTestSpan(traceID, spanID, "batch-test-span", false)
		spans = append(spans, span)
	}

	// Export all spans
	err := exporter.ExportSpans(context.Background(), spans)
	if err != nil {
		t.Fatalf("Failed to export spans: %v", err)
	}

	// Wait for async processing to complete
	time.Sleep(500 * time.Millisecond)

	// Verify all spans were processed
	queries := db.New(database)
	dbSpans, err := queries.GetTraceDetails(context.Background(), "1234567890abcdef1234567890abcdef")
	if err != nil {
		t.Fatalf("Failed to query spans: %v", err)
	}

	if len(dbSpans) != 250 {
		t.Errorf("Expected 250 spans, got %d", len(dbSpans))
	}
}

func TestSQLiteSpanExporter_Shutdown(t *testing.T) {
	database := setupTestDB(t)
	defer database.Close()

	exporter := NewSQLiteSpanExporter(database)

	// Add some spans to the queue
	span := createTestSpan("1234567890abcdef1234567890abcdef", "1234567890abcdef", "shutdown-test", false)
	spans := []trace.ReadOnlySpan{span}
	
	err := exporter.ExportSpans(context.Background(), spans)
	if err != nil {
		t.Fatalf("Failed to export spans: %v", err)
	}

	// Test shutdown with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	err = exporter.Shutdown(ctx)
	if err != nil {
		t.Fatalf("Failed to shutdown exporter: %v", err)
	}

	// Verify the span was processed before shutdown
	queries := db.New(database)
	dbSpans, err := queries.GetTraceDetails(context.Background(), "1234567890abcdef1234567890abcdef")
	if err != nil {
		t.Fatalf("Failed to query spans: %v", err)
	}

	if len(dbSpans) != 1 {
		t.Errorf("Expected 1 span to be processed during shutdown, got %d", len(dbSpans))
	}
}

func TestSQLiteSpanExporter_ShutdownTimeout(t *testing.T) {
	database := setupTestDB(t)
	defer database.Close()

	exporter := NewSQLiteSpanExporter(database)

	// Create a context that times out immediately
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Nanosecond)
	defer cancel()

	// Shutdown should return context.DeadlineExceeded
	err := exporter.Shutdown(ctx)
	if err != context.DeadlineExceeded {
		t.Errorf("Expected context.DeadlineExceeded, got %v", err)
	}
}

func TestSQLiteSpanExporter_ConcurrentExport(t *testing.T) {
	database := setupTestDB(t)
	defer database.Close()

	exporter := NewSQLiteSpanExporter(database)
	defer exporter.Shutdown(context.Background())

	// Test concurrent exports
	const numGoroutines = 10
	const spansPerGoroutine = 50
	
	done := make(chan bool, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(routineID int) {
			defer func() { done <- true }()
			
			var spans []trace.ReadOnlySpan
			for j := 0; j < spansPerGoroutine; j++ {
				traceID := "1234567890abcdef1234567890abcdef"
				spanID := "123456789012345" + string(rune('0'+j%10))
				span := createTestSpan(traceID, spanID, "concurrent-test", false)
				spans = append(spans, span)
			}
			
			err := exporter.ExportSpans(context.Background(), spans)
			if err != nil {
				t.Errorf("Goroutine %d failed to export spans: %v", routineID, err)
			}
		}(i)
	}

	// Wait for all goroutines to finish
	for i := 0; i < numGoroutines; i++ {
		<-done
	}

	// Wait for processing
	time.Sleep(1 * time.Second)

	// Verify all spans were processed
	queries := db.New(database)
	dbSpans, err := queries.GetTraceDetails(context.Background(), "1234567890abcdef1234567890abcdef")
	if err != nil {
		t.Fatalf("Failed to query spans: %v", err)
	}

	expectedTotal := numGoroutines * spansPerGoroutine
	if len(dbSpans) != expectedTotal {
		t.Errorf("Expected %d spans, got %d", expectedTotal, len(dbSpans))
	}
} 