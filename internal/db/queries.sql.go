// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) FROM logs
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsWithFilters = `-- name: CountLogsWithFilters :one
SELECT COUNT(*) FROM logs
WHERE 
  (?1 IS NULL OR level = ?1)
  AND (?2 IS NULL OR trace_id = ?2)
  AND (?3 IS NULL OR timestamp >= ?3)
  AND (?4 IS NULL OR timestamp <= ?4)
`

type CountLogsWithFiltersParams struct {
	Level     interface{}
	TraceID   interface{}
	StartTime interface{}
	EndTime   interface{}
}

func (q *Queries) CountLogsWithFilters(ctx context.Context, arg CountLogsWithFiltersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogsWithFilters,
		arg.Level,
		arg.TraceID,
		arg.StartTime,
		arg.EndTime,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTraces = `-- name: CountTraces :one
SELECT COUNT(DISTINCT trace_id) FROM spans
WHERE parent_span_id IS NULL OR parent_span_id = ''
`

func (q *Queries) CountTraces(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTraces)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLogs = `-- name: GetLogs :many
SELECT id, timestamp, level, message, trace_id, span_id, attributes FROM logs
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type GetLogsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.TraceID,
			&i.SpanID,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsWithFilters = `-- name: GetLogsWithFilters :many
SELECT id, timestamp, level, message, trace_id, span_id, attributes FROM logs
WHERE 
  (?1 IS NULL OR level = ?1)
  AND (?2 IS NULL OR trace_id = ?2)
  AND (?3 IS NULL OR timestamp >= ?3)
  AND (?4 IS NULL OR timestamp <= ?4)
ORDER BY timestamp DESC
LIMIT ?6 OFFSET ?5
`

type GetLogsWithFiltersParams struct {
	Level     interface{}
	TraceID   interface{}
	StartTime interface{}
	EndTime   interface{}
	Offset    int64
	Limit     int64
}

func (q *Queries) GetLogsWithFilters(ctx context.Context, arg GetLogsWithFiltersParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsWithFilters,
		arg.Level,
		arg.TraceID,
		arg.StartTime,
		arg.EndTime,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Level,
			&i.Message,
			&i.TraceID,
			&i.SpanID,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootSpans = `-- name: GetRootSpans :many
SELECT trace_id, name, start_time, end_time
FROM spans
WHERE parent_span_id IS NULL OR parent_span_id = ''
ORDER BY start_time DESC
LIMIT ? OFFSET ?
`

type GetRootSpansParams struct {
	Limit  int64
	Offset int64
}

type GetRootSpansRow struct {
	TraceID   string
	Name      string
	StartTime string
	EndTime   string
}

func (q *Queries) GetRootSpans(ctx context.Context, arg GetRootSpansParams) ([]GetRootSpansRow, error) {
	rows, err := q.db.QueryContext(ctx, getRootSpans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRootSpansRow
	for rows.Next() {
		var i GetRootSpansRow
		if err := rows.Scan(
			&i.TraceID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTraceDetails = `-- name: GetTraceDetails :many
SELECT span_id, trace_id, parent_span_id, name, start_time, end_time, duration_ns, attributes, service_name, has_error FROM spans
WHERE trace_id = ?
ORDER BY start_time ASC
`

func (q *Queries) GetTraceDetails(ctx context.Context, traceID string) ([]Span, error) {
	rows, err := q.db.QueryContext(ctx, getTraceDetails, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Span
	for rows.Next() {
		var i Span
		if err := rows.Scan(
			&i.SpanID,
			&i.TraceID,
			&i.ParentSpanID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.DurationNs,
			&i.Attributes,
			&i.ServiceName,
			&i.HasError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTraceStats = `-- name: GetTraceStats :many
SELECT 
  trace_id,
  COUNT(*) as span_count,
  SUM(CASE WHEN has_error THEN 1 ELSE 0 END) as error_count
FROM spans
GROUP BY trace_id
`

type GetTraceStatsRow struct {
	TraceID    string
	SpanCount  int64
	ErrorCount sql.NullFloat64
}

func (q *Queries) GetTraceStats(ctx context.Context) ([]GetTraceStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTraceStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTraceStatsRow
	for rows.Next() {
		var i GetTraceStatsRow
		if err := rows.Scan(&i.TraceID, &i.SpanCount, &i.ErrorCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLog = `-- name: InsertLog :exec
INSERT INTO logs (
  timestamp, level, message, trace_id, span_id, attributes
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type InsertLogParams struct {
	Timestamp  string
	Level      string
	Message    string
	TraceID    sql.NullString
	SpanID     sql.NullString
	Attributes sql.NullString
}

func (q *Queries) InsertLog(ctx context.Context, arg InsertLogParams) error {
	_, err := q.db.ExecContext(ctx, insertLog,
		arg.Timestamp,
		arg.Level,
		arg.Message,
		arg.TraceID,
		arg.SpanID,
		arg.Attributes,
	)
	return err
}

const insertSpan = `-- name: InsertSpan :exec
INSERT INTO spans (
  span_id, trace_id, parent_span_id, name, start_time, end_time, duration_ns, attributes, service_name, has_error
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertSpanParams struct {
	SpanID       string
	TraceID      string
	ParentSpanID sql.NullString
	Name         string
	StartTime    string
	EndTime      string
	DurationNs   int64
	Attributes   sql.NullString
	ServiceName  string
	HasError     bool
}

func (q *Queries) InsertSpan(ctx context.Context, arg InsertSpanParams) error {
	_, err := q.db.ExecContext(ctx, insertSpan,
		arg.SpanID,
		arg.TraceID,
		arg.ParentSpanID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.DurationNs,
		arg.Attributes,
		arg.ServiceName,
		arg.HasError,
	)
	return err
}
